{"version":3,"sources":["is-string.ts","parse-deep-pattern.ts","trim-all.ts","parse-fork-pattern.ts","parse-wide-pattern.ts","mocktail.ts"],"names":[],"mappings":";AAAA,aAAA,SAAgB,EAAS,GACd,MAAiB,iBAAV,GAAsB,aAAwB,OADhE,OAAA,eAAA,QAAA,aAAA,CAAA,OAAA,IAAA,QAAA,SAAA;;ACOA,aAAA,SAAgB,EAAiB,EAAuB,GAAxD,IAAA,EACU,EAAiB,EAAc,MAAM,KAM3C,OAAA,EAAA,IAAU,EAAK,SAJN,SAAA,EAAS,GAHtB,IAAA,EAIe,OAAA,EAAW,OAAS,IAAG,EAAA,IAAI,EAAW,SAAoB,EAAS,GAAW,GAAK,EAG3D,CAAS,GAAK,EAPrD,OAAA,eAAA,QAAA,aAAA,CAAA,OAAA,IAAA,QAAA,iBAAA;;ACEa,aAAA,OAAA,eAAA,QAAA,aAAA,CAAA,OAAA,IATb,IAAM,EAAiC,SAAC,GAAiB,OAAA,IAAI,OAAO,IAAI,EAAI,MACtE,EAAkC,SAAC,GAAiB,OAAA,IAAI,OAAU,EAAI,OAQ/D,QAAA,QAAU,SAAC,GAAwC,OAAA,SAAC,GACtD,OAAA,EAAM,QAAQ,EAAQ,GAAO,IAAI,QAAQ,EAAS,GAAO;;ACDpE,aAAA,OAAA,eAAA,QAAA,aAAA,CAAA,OAAA,IARA,IAAA,EAAA,QAAA,cAQA,SAAgB,EAAiB,GAOtB,IAND,IAIF,EAJE,EAAsB,sBACtB,EAAgB,EAAA,QAAQ,KACxB,EAAoB,EAAA,QAAQ,KAC5B,EAAgB,GAGf,EAAY,KAAK,IACb,EAAA,EAAY,KAAK,GACR,EAAA,EAAc,QAAQ,EAAK,GAAI,IACzC,EAAA,KAAK,CAAE,IAAK,EAAK,GAAI,MAAO,EAAkB,EAAK,GAAG,QAAQ,EAAK,GAAK,IAAK,OAOhF,OAJH,EAAc,QACR,EAAA,KAAK,CAAE,IAAK,KAAM,MAAO,EAAc,KAG1C,EAjBX,QAAA,iBAAA;;ACHA,aAAA,SAAgB,EAAiB,GACtB,OAAA,EAAc,MAAM,KAD/B,OAAA,eAAA,QAAA,aAAA,CAAA,OAAA,IAAA,QAAA,iBAAA;;ACOA,aAAA,OAAA,eAAA,QAAA,aAAA,CAAA,OAAA,IAZA,IAAA,EAAA,QAAA,eACA,EAAA,QAAA,wBACA,EAAA,QAAA,wBACA,EAAA,QAAA,wBASA,SAAgB,EAAS,GAAuB,IAAA,IAAA,EAAA,GAAA,EAAA,EAAA,EAAA,UAAA,OAAA,IAAA,EAAA,EAAA,GAAA,UAAA,GACpC,IAAA,EAAA,OAAA,OAEJ,GAAA,EAAA,SAAS,GAAgB,CACnB,IAAA,EAAgB,EAAA,iBAAiB,GACnC,EAAkB,GAClB,EAAe,GACb,EAAe,GAcd,OAZD,EAAA,QAAQ,SAAC,GACH,EAAA,EAAA,iBAAiB,EAAK,OAAO,IAAI,SAAC,GAAS,OAAA,EAAA,iBAAiB,EAAM,EAAY,WAG3E,EADM,OAAb,EAAK,IACE,EAAO,MAAM,KAAM,GAEnB,EAAA,iBAAiB,EAAK,IAAK,EAAO,MAAM,KAAM,IAGlD,EAAA,EAAM,KAGV,EAEA,MAAA,GAvBf,QAAA,SAAA","file":"mocktail.map","sourceRoot":"../src","sourcesContent":["export function isString(value: any): boolean {\n    return typeof value === \"string\" || value as any instanceof String;\n}\n","/**\n * Parses the so-called `deep` object off of the provided pattern.\n *\n * @param objectPattern {string} the pattern off of which a `deep` object is parsed\n * @param nestedValue {any} the value/-s to be assigned to the nested keys\n * @returns {object} the parsed `deep` object\n */\nexport function parseDeepPattern(objectPattern: string, nestedValue?: any): object {\n    const keys: string[] = objectPattern.split(\".\");\n\n    function evaluate(fieldNames: string[]): any {\n        return fieldNames.length > 0 ? { [fieldNames.shift() as string]: evaluate(fieldNames) } : nestedValue;\n    }\n\n    return { [keys.shift() as string]: evaluate(keys) };\n}\n","const leading: (_: string) => RegExp = (char: string) => new RegExp(`^${char}*`);\nconst trailing: (_: string) => RegExp = (char: string) => new RegExp(`${char}*$`);\n\n/**\n * Trims all leading and trailing occurences of the specified character.\n * This is a curried function.\n *\n * @param char {string} the character to be trimmed\n */\nexport const trimAll = (char: string): (_: string) => string => (value: string): string => {\n    return value.replace(leading(char), \"\").replace(trailing(char), \"\");\n};\n","import { Fork } from \"./fork\";\nimport { trimAll } from \"./trim-all\";\n\n/**\n * Parses the so-called `fork` object array off of the provided pattern.\n *\n * @param objectPattern {string} the pattern off of which a `fork` object array is parsed\n * @returns {object} the parsed `fork` object array\n */\nexport function parseForkPattern(objectPattern: string): Fork[] {\n    const forkPattern: RegExp = /([a-z.]*):[a-z.,]*;/;\n    const trimAllCommas = trimAll(\",\");\n    const trimAllSemicolons = trimAll(\";\");\n    const forks: Fork[] = [];\n    let fork: RegExpExecArray;\n\n    while (forkPattern.test(objectPattern)) {\n        fork = forkPattern.exec(objectPattern) as RegExpExecArray;\n        objectPattern = objectPattern.replace(fork[0], \"\");\n        forks.push({ key: fork[1], value: trimAllSemicolons(fork[0].replace(fork[1] + \":\", \"\")) });\n    }\n\n    if (objectPattern.length) {\n        forks.push({ key: null, value: trimAllCommas(objectPattern) });\n    }\n\n    return forks;\n}\n","/**\n * Parses the so-called `wide` object string off of the provided pattern.\n *\n * @param objectPattern {string} the pattern off of which a `wide` object string is parsed\n * @returns {string} the parsed `wide` object string\n */\nexport function parseWidePattern(objectPattern: string): string[] {\n    return objectPattern.split(\",\");\n}\n","import { Fork } from \"./fork\";\nimport { isString } from \"./is-string\";\nimport { parseDeepPattern } from \"./parse-deep-pattern\";\nimport { parseForkPattern } from \"./parse-fork-pattern\";\nimport { parseWidePattern } from \"./parse-wide-pattern\";\n\n/**\n * Mocks a JavaScript object off of the provided pattern.\n *\n * @param objectPattern {string} the pattern off of which a mock object is built\n * @param nestedValue {*} the value/-s to be assigned to the nested keys\n * @returns {object} the object parsed from the objectPattern\n */\nexport function mocktail(objectPattern: string, ...nestedValue: any[]): object {\n    const { assign } = Object as any;\n\n    if (isString(objectPattern)) {\n        const forks: Fork[] = parseForkPattern(objectPattern);\n        let wides: object[] = [];\n        let deep: object = {};\n        const mock: object = {};\n\n        forks.forEach((fork: Fork) => {\n            wides = parseWidePattern(fork.value).map((wide) => parseDeepPattern(wide, nestedValue.shift()));\n\n            if (fork.key === null) {\n                deep = assign.apply(null, wides);\n            } else {\n                deep = parseDeepPattern(fork.key, assign.apply(null, wides));\n            }\n\n            assign(mock, deep);\n        });\n\n        return mock;\n    } else {\n        return {};\n    }\n}\n"]}