{"version":3,"file":"mocktail.js","sources":["../src/is-string.ts","../src/parse-deep-pattern.ts","../src/trim-all.ts","../src/parse-fork-pattern.ts","../src/parse-wide-pattern.ts","../src/mocktail.ts"],"sourcesContent":["export function isString(value: unknown): value is string {\r\n    return typeof value === \"string\" || value instanceof String;\r\n}\r\n","/**\r\n * Parses the so-called `deep` object off of the provided pattern.\r\n */\r\nexport function parseDeepPattern(objectPattern: string, nestedValue?: unknown): Record<string, unknown> {\r\n    const keys: string[] = objectPattern.split(\".\");\r\n\r\n    function evaluate(fieldNames: string[]): Record<string, unknown> | unknown {\r\n        return fieldNames.length > 0 ? { [fieldNames.shift() as string]: evaluate(fieldNames) } : nestedValue;\r\n    }\r\n\r\n    return evaluate(keys) as Record<string, unknown>;\r\n}\r\n","const leading: (_: string) => RegExp = (char: string) => new RegExp(`^${char}*`);\r\nconst trailing: (_: string) => RegExp = (char: string) => new RegExp(`${char}*$`);\r\n\r\n/**\r\n * Trims all leading and trailing occurences of the specified character.\r\n */\r\nexport const trimAll = (char: string) => (value: string): string =>\r\n    value.replace(leading(char), \"\").replace(trailing(char), \"\");\r\n","import { Fork } from \"./fork\";\r\nimport { trimAll } from \"./trim-all\";\r\n\r\n/**\r\n * Parses the so-called `fork` object array off of the provided pattern.\r\n */\r\nexport function parseForkPattern(objectPattern: string): Fork[] {\r\n    const forkPattern = /([a-z.]*):[a-z.,]*;/;\r\n    const trimAllCommas = trimAll(\",\");\r\n    const trimAllSemicolons = trimAll(\";\");\r\n    const forks: Fork[] = [];\r\n    let fork: RegExpExecArray;\r\n\r\n    while (forkPattern.test(objectPattern)) {\r\n        fork = forkPattern.exec(objectPattern) as RegExpExecArray;\r\n        objectPattern = objectPattern.replace(fork[0], \"\");\r\n        forks.push({ key: fork[1], value: trimAllSemicolons(fork[0].replace(fork[1] + \":\", \"\")) });\r\n    }\r\n\r\n    if (objectPattern.length) {\r\n        forks.push({ key: null, value: trimAllCommas(objectPattern) });\r\n    }\r\n\r\n    return forks;\r\n}\r\n","/**\r\n * Parses the so-called `wide` object string off of the provided pattern.\r\n */\r\nexport function parseWidePattern(objectPattern: string): string[] {\r\n    return objectPattern.split(\",\");\r\n}\r\n","import { Fork } from \"./fork\";\r\nimport { isString } from \"./is-string\";\r\nimport { parseDeepPattern } from \"./parse-deep-pattern\";\r\nimport { parseForkPattern } from \"./parse-fork-pattern\";\r\nimport { parseWidePattern } from \"./parse-wide-pattern\";\r\n\r\n/**\r\n * Mocks a JavaScript object off of the provided pattern.\r\n */\r\nexport function mocktail(objectPattern: unknown, ...nestedValue: unknown[]): Record<string, unknown> {\r\n    const mock: Record<string, unknown> = {};\r\n\r\n    if (isString(objectPattern)) {\r\n        const forks: Fork[] = parseForkPattern(objectPattern);\r\n        let wides: Array<Record<string, unknown>> = [];\r\n        let deep: Record<string, unknown> = {};\r\n\r\n        forks.forEach((fork: Fork) => {\r\n            wides = parseWidePattern(fork.value).map((wide) => parseDeepPattern(wide, nestedValue.shift()));\r\n            deep = fork.key === null\r\n                ? Object.assign({}, ...wides) as Record<string, unknown>\r\n                : parseDeepPattern(fork.key, Object.assign({}, ...wides));\r\n            Object.assign(mock, deep);\r\n        });\r\n    }\r\n\r\n    return mock;\r\n}\r\n"],"names":[],"mappings":"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"}