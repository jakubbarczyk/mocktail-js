{"version":3,"sources":["is-string.ts","parse-deep-pattern.ts","trim-all.ts","parse-fork-pattern.ts","parse-wide-pattern.ts","mocktail.ts"],"names":[],"mappings":";AAAA,aAAA,SAAgB,EAAS,GACd,MAAiB,iBAAV,GAAsB,aAAwB,OADhE,OAAA,eAAA,QAAA,aAAA,CAAA,OAAA,IAAA,QAAA,SAAA;;ACOA,aAAA,SAAgB,EAAiB,EAAuB,GAAxD,IAAA,EACU,EAAiB,EAAc,MAAM,KAM3C,OAAA,EAAA,IAAU,EAAK,SAJN,SAAA,EAAS,GAHtB,IAAA,EAIe,OAAA,EAAW,OAAS,IAAG,EAAA,IAAI,EAAW,SAAoB,EAAS,GAAW,GAAK,EAG3D,CAAS,GAAK,EAPrD,OAAA,eAAA,QAAA,aAAA,CAAA,OAAA,IAAA,QAAA,iBAAA;;ACEa,aAAA,OAAA,eAAA,QAAA,aAAA,CAAA,OAAA,IATb,IAAM,EAAiC,SAAC,GAAiB,OAAA,IAAI,OAAO,IAAI,EAAI,MACtE,EAAkC,SAAC,GAAiB,OAAA,IAAI,OAAU,EAAI,OAQ/D,QAAA,QAAU,SAAC,GAAwC,OAAA,SAAC,GACtD,OAAA,EAAM,QAAQ,EAAQ,GAAO,IAAI,QAAQ,EAAS,GAAO;;ACDpE,aAAA,OAAA,eAAA,QAAA,aAAA,CAAA,OAAA,IARA,IAAA,EAAA,QAAA,cAQA,SAAgB,EAAiB,GAOtB,IAND,IAIF,EAJE,EAAsB,sBACtB,EAAgB,EAAA,QAAQ,KACxB,EAAoB,EAAA,QAAQ,KAC5B,EAAgB,GAGf,EAAY,KAAK,IACpB,EAAO,EAAY,KAAK,GACxB,EAAgB,EAAc,QAAQ,EAAK,GAAI,IAC/C,EAAM,KAAK,CAAE,IAAK,EAAK,GAAI,MAAO,EAAkB,EAAK,GAAG,QAAQ,EAAK,GAAK,IAAK,OAOhF,OAJH,EAAc,QACd,EAAM,KAAK,CAAE,IAAK,KAAM,MAAO,EAAc,KAG1C,EAjBX,QAAA,iBAAA;;ACHA,aAAA,SAAgB,EAAiB,GACtB,OAAA,EAAc,MAAM,KAD/B,OAAA,eAAA,QAAA,aAAA,CAAA,OAAA,IAAA,QAAA,iBAAA;;ACOA,aAAA,OAAA,eAAA,QAAA,aAAA,CAAA,OAAA,IAZA,IAAA,EAAA,QAAA,eACA,EAAA,QAAA,wBACA,EAAA,QAAA,wBACA,EAAA,QAAA,wBASA,SAAgB,EAAS,GAAuB,IAAA,IAAA,EAAA,GAAA,EAAA,EAAA,EAAA,UAAA,OAAA,IAAA,EAAA,EAAA,GAAA,UAAA,GACpC,IAAA,EAAA,OAAA,OAEJ,GAAA,EAAA,SAAS,GAAgB,CACnB,IAAA,EAAgB,EAAA,iBAAiB,GACnC,EAAkB,GAClB,EAAe,GACb,EAAe,GAcd,OAZP,EAAM,QAAQ,SAAC,GACX,EAAQ,EAAA,iBAAiB,EAAK,OAAO,IAAI,SAAC,GAAS,OAAA,EAAA,iBAAiB,EAAM,EAAY,WAGlF,EADa,OAAb,EAAK,IACE,EAAO,MAAM,KAAM,GAEnB,EAAA,iBAAiB,EAAK,IAAK,EAAO,MAAM,KAAM,IAGzD,EAAO,EAAM,KAGV,EAEA,MAAA,GAvBf,QAAA,SAAA","file":"mocktail.js","sourceRoot":"..\\src","sourcesContent":["export function isString(value: any): boolean {\r\n    return typeof value === \"string\" || value as any instanceof String;\r\n}\r\n","/**\r\n * Parses the so-called `deep` object off of the provided pattern.\r\n *\r\n * @param objectPattern {string} the pattern off of which a `deep` object is parsed\r\n * @param nestedValue {any} the value/-s to be assigned to the nested keys\r\n * @returns {object} the parsed `deep` object\r\n */\r\nexport function parseDeepPattern(objectPattern: string, nestedValue?: any): object {\r\n    const keys: string[] = objectPattern.split(\".\");\r\n\r\n    function evaluate(fieldNames: string[]): any {\r\n        return fieldNames.length > 0 ? { [fieldNames.shift() as string]: evaluate(fieldNames) } : nestedValue;\r\n    }\r\n\r\n    return { [keys.shift() as string]: evaluate(keys) };\r\n}\r\n","const leading: (_: string) => RegExp = (char: string) => new RegExp(`^${char}*`);\r\nconst trailing: (_: string) => RegExp = (char: string) => new RegExp(`${char}*$`);\r\n\r\n/**\r\n * Trims all leading and trailing occurences of the specified character.\r\n * This is a curried function.\r\n *\r\n * @param char {string} the character to be trimmed\r\n */\r\nexport const trimAll = (char: string): (_: string) => string => (value: string): string => {\r\n    return value.replace(leading(char), \"\").replace(trailing(char), \"\");\r\n};\r\n","import { Fork } from \"./fork\";\r\nimport { trimAll } from \"./trim-all\";\r\n\r\n/**\r\n * Parses the so-called `fork` object array off of the provided pattern.\r\n *\r\n * @param objectPattern {string} the pattern off of which a `fork` object array is parsed\r\n * @returns {object} the parsed `fork` object array\r\n */\r\nexport function parseForkPattern(objectPattern: string): Fork[] {\r\n    const forkPattern: RegExp = /([a-z.]*):[a-z.,]*;/;\r\n    const trimAllCommas = trimAll(\",\");\r\n    const trimAllSemicolons = trimAll(\";\");\r\n    const forks: Fork[] = [];\r\n    let fork: RegExpExecArray;\r\n\r\n    while (forkPattern.test(objectPattern)) {\r\n        fork = forkPattern.exec(objectPattern) as RegExpExecArray;\r\n        objectPattern = objectPattern.replace(fork[0], \"\");\r\n        forks.push({ key: fork[1], value: trimAllSemicolons(fork[0].replace(fork[1] + \":\", \"\")) });\r\n    }\r\n\r\n    if (objectPattern.length) {\r\n        forks.push({ key: null, value: trimAllCommas(objectPattern) });\r\n    }\r\n\r\n    return forks;\r\n}\r\n","/**\r\n * Parses the so-called `wide` object string off of the provided pattern.\r\n *\r\n * @param objectPattern {string} the pattern off of which a `wide` object string is parsed\r\n * @returns {string} the parsed `wide` object string\r\n */\r\nexport function parseWidePattern(objectPattern: string): string[] {\r\n    return objectPattern.split(\",\");\r\n}\r\n","import { Fork } from \"./fork\";\r\nimport { isString } from \"./is-string\";\r\nimport { parseDeepPattern } from \"./parse-deep-pattern\";\r\nimport { parseForkPattern } from \"./parse-fork-pattern\";\r\nimport { parseWidePattern } from \"./parse-wide-pattern\";\r\n\r\n/**\r\n * Mocks a JavaScript object off of the provided pattern.\r\n *\r\n * @param objectPattern {string} the pattern off of which a mock object is built\r\n * @param nestedValue {*} the value/-s to be assigned to the nested keys\r\n * @returns {object} the object parsed from the objectPattern\r\n */\r\nexport function mocktail(objectPattern: string, ...nestedValue: any[]): object {\r\n    const { assign } = Object as any;\r\n\r\n    if (isString(objectPattern)) {\r\n        const forks: Fork[] = parseForkPattern(objectPattern);\r\n        let wides: object[] = [];\r\n        let deep: object = {};\r\n        const mock: object = {};\r\n\r\n        forks.forEach((fork: Fork) => {\r\n            wides = parseWidePattern(fork.value).map((wide) => parseDeepPattern(wide, nestedValue.shift()));\r\n\r\n            if (fork.key === null) {\r\n                deep = assign.apply(null, wides);\r\n            } else {\r\n                deep = parseDeepPattern(fork.key, assign.apply(null, wides));\r\n            }\r\n\r\n            assign(mock, deep);\r\n        });\r\n\r\n        return mock;\r\n    } else {\r\n        return {};\r\n    }\r\n}\r\n"]}