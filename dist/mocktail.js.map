{"version":3,"sources":["is-string.ts","parse-deep-pattern.ts","trim-all.ts","parse-fork-pattern.ts","parse-wide-pattern.ts","mocktail.ts"],"names":[],"mappings":"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","file":"mocktail.js","sourceRoot":"..\\src","sourcesContent":["export function isString(value: unknown): boolean {\r\n    return typeof value === \"string\" || value instanceof String;\r\n}\r\n","/**\r\n * Parses the so-called `deep` object off of the provided pattern.\r\n */\r\nexport function parseDeepPattern(objectPattern: string, nestedValue?: unknown): Record<string, unknown> {\r\n    const keys: string[] = objectPattern.split(\".\");\r\n\r\n    function evaluate(fieldNames: string[]): Record<string, unknown> | unknown {\r\n        return fieldNames.length > 0 ? { [fieldNames.shift() as string]: evaluate(fieldNames) } : nestedValue;\r\n    }\r\n\r\n    return evaluate(keys) as Record<string, unknown>;\r\n}\r\n","const leading: (_: string) => RegExp = (char: string) => new RegExp(`^${char}*`);\r\nconst trailing: (_: string) => RegExp = (char: string) => new RegExp(`${char}*$`);\r\n\r\n/**\r\n * Trims all leading and trailing occurences of the specified character.\r\n */\r\nexport const trimAll = (char: string) => (value: string): string =>\r\n    value.replace(leading(char), \"\").replace(trailing(char), \"\");\r\n","import { Fork } from \"./fork\";\r\nimport { trimAll } from \"./trim-all\";\r\n\r\n/**\r\n * Parses the so-called `fork` object array off of the provided pattern.\r\n */\r\nexport function parseForkPattern(objectPattern: string): Fork[] {\r\n    const forkPattern = /([a-z.]*):[a-z.,]*;/;\r\n    const trimAllCommas = trimAll(\",\");\r\n    const trimAllSemicolons = trimAll(\";\");\r\n    const forks: Fork[] = [];\r\n    let fork: RegExpExecArray;\r\n\r\n    while (forkPattern.test(objectPattern)) {\r\n        fork = forkPattern.exec(objectPattern) as RegExpExecArray;\r\n        objectPattern = objectPattern.replace(fork[0], \"\");\r\n        forks.push({ key: fork[1], value: trimAllSemicolons(fork[0].replace(fork[1] + \":\", \"\")) });\r\n    }\r\n\r\n    if (objectPattern.length) {\r\n        forks.push({ key: null, value: trimAllCommas(objectPattern) });\r\n    }\r\n\r\n    return forks;\r\n}\r\n","/**\r\n * Parses the so-called `wide` object string off of the provided pattern.\r\n */\r\nexport function parseWidePattern(objectPattern: string): string[] {\r\n    return objectPattern.split(\",\");\r\n}\r\n","import { Fork } from \"./fork\";\r\nimport { isString } from \"./is-string\";\r\nimport { parseDeepPattern } from \"./parse-deep-pattern\";\r\nimport { parseForkPattern } from \"./parse-fork-pattern\";\r\nimport { parseWidePattern } from \"./parse-wide-pattern\";\r\n\r\n/**\r\n * Mocks a JavaScript object off of the provided pattern.\r\n */\r\nexport function mocktail(objectPattern: string, ...nestedValue: unknown[]): Record<string, unknown> {\r\n    const mock: Record<string, unknown> = {};\r\n\r\n    if (isString(objectPattern)) {\r\n        const forks: Fork[] = parseForkPattern(objectPattern);\r\n        let wides: Array<Record<string, unknown>> = [];\r\n        let deep: Record<string, unknown> = {};\r\n\r\n        forks.forEach((fork: Fork) => {\r\n            wides = parseWidePattern(fork.value).map((wide) => parseDeepPattern(wide, nestedValue.shift()));\r\n            deep = fork.key === null\r\n                ? Object.assign({}, ...wides) as Record<string, unknown>\r\n                : parseDeepPattern(fork.key, Object.assign({}, ...wides));\r\n            Object.assign(mock, deep);\r\n        });\r\n    }\r\n\r\n    return mock;\r\n}\r\n"]}